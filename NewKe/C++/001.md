针对以下代码，
``` C++
const char str1[]=”abc”;
const char str2[]=”abc”;
const char *p1 = “abc”;
const char *p2 = “abc”;
```
判断下列说法哪个是正确的：


- A str1和str2地址不同，P1和P2地址相同。
- B str1和str2地址相同，P1和P2地址相同。
- C str1和str2地址不同，P1和P2地址不同。
- D str1和str2地址相同，P1和P2地址不同。
- E 4个地址都相同

答案：C

----





下面函数的执行结果是输出
``` C++
char str[]=”xunlei”;
char *p=str;
int n=10;
printf(“%d,%d,%d\n”,sizeof(str),sizeof(p),sizeof(n));
```

答案：7,4,4

----

设有如下定义： 
``` C++
unsigned long pulArray[]={6,7,8,9,10};
unsigned long *pulPtr;
```
则下列程序段的输出结果为多少？
``` C++
pulPtr=pulArray;
*(pulPtr+2)+=2;
printf("%d,%d\n",*pulPtr,*(pulPtr+2));
```

答案：6，10


----


给定fun函数如下，那么fun(10)的输出结果是（）
``` C++
int fun(int x)
{
    return (x == 1) ? 1 : (x + fun(x - 1));
}
```

答案：55


----


在c++中，

``` C++
const int i = 0; 
int *j = (int *) &i; 
*j = 1; 
printf("%d,%d", i, *j)
```

输出是多少?

答案：0，1

C++中的常量折叠：指const变量（即常量）值 放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。

注: 在C语言中输出为1，1，在C++中输出为0，1. C语言中的const是运行时const，编译时只是定义，在运行才会初始化。C语言中const变量不能用于成为数组长度等作为编译时常量的情况，原因就在此。C语言const变量在运行时改变了是可以再次读出改变后的值的。

C++中，const变量是编译时的常量，可以向#define定义的常量一样使用。故C++中const变量的值在编译时就已经确定了，直接对cosnt变量进行了值的替换，因此当const变量的值改变时，const的变量值是不会得到更新的。编译器只对const变量的值读取一次。所以打印的是0


---
在x86系统下,sizeof如下结构体的值是多少?

``` C++
struct{ 
char a[10];
int b;
short c[3];
}
```

答案：24 字节

注：偏移量必须为其类型的整数倍，结构体大小必须是所有成员大小的整数倍char 偏移量0，地址0-9int    偏移量10不是sizeof(int)的倍数，故而修正为12，地址12-15 short 偏移量16，地址16-21 结构题大小22不是1，2，4的公倍数，故而vc自动补充2个数为24，即里面的是指针!!

---

有以下程序
``` C++
#include <iostream>
using namespace std;
int fun (int x,int y)
{
    if(x==y)
        return (x);
    else
        return ((x+y)/2);
}
int main()
{  
    int a=4,b=5,c=6;
    printf("%d\n",fun(2*a,fun(b,c)));
}

```
下面程序的输出是？

答案：6

---

下面函数的时间复杂度是
``` C++
long foo(long x){
    if(x<2) return 1;
        return x*x*foo(x-1);
}
``` 

答案$O(N)$

---

请选择下面代码的输出结果

``` C++
int main(int argc,char*argv[])
{
    int a=10;
    int b=4;
    int c=a/b;
    int d=c*a*b++;
    std:cout<<d<<std::endl;
    return 0;
}

```
答案：80

---

如果类B继承类A，A::x()被声明为虚函数，B::x()重载了A::x()方法，在下述语句中哪个x()方法会被调用：

``` C++
B b;
b.x();
``` 


- **A**  A::x()
- **B**  B::x()
- **C**  A::x() B::x()
- **D**  B::x() A::x()

答案：B



----
以下代码的输出是（）
``` C++
int a[5]={1,2,3,4,5};
int *ptr=(int*)(&a+1);
printf("%d,%d",*(a+1),*(ptr-1));
``` 


答案：2，5

注：a 代表的是int * 每次步长为一个int；&a 代表的是 int[]* 每次步长为所指向的数组的大小。故ptr 指向的是数组a最后一个元素的下一个元素，所以ptr-1指向的是数组a的最后一个元素，a+1指向的是数组a的第二个元素

---

以下程序的输出结果是：
``` C++
#include <iostream>
using namespace std;
void func(char **m){
    ++m;
    cout<<*m<<endl;
}
int main(){
    static char *a[]={"morning", "afternoon", "evening"};
    char **p;
    p=a;
    func(p);
    return 0;
}

```


答案：afternoon



---

在C++语言中，下列说法正确的是：

- **A**  inline函数表示编译器一定会将函数体直接插入到调用此函数的地方，这样可以加快程序的运行速度
- **B**  局部变量和全局变量不能重名
- **C**  静态局部变量内存是在运行期分配的，存储在堆栈区
- **D**  C++不是类型安全的语言

答案：D

注：针对内联函数（以下语句来自C++ primer 5th）：

内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。



----

以下字符串定义与赋值中，正确的是（）


- **A** char s[80] = {"A", "B" ,"C"}
- **B** char s[80]; s = {'A', 'B','C'}
- **C** char s[80]; s = "ABC";
- **D** char s[80] ="ABC";

答案：D

注：字符数组初始化有俩种方法：

- 1.用字符为数组赋初值，A选项等式右边所有字符如果使用单引号，则也正确
- 2.用字符串常量赋初值，即D选项，注意字符串用双引号
除此以外，都是错的。


---


已知n阶矩阵A的行列式满足$|A|=1$,求$|A^{-1}|$( $A^{-1}$表示A的逆矩阵）=？

答案：1


----


有如下一段程序：
``` C++
int f1(float);
int f2(char);
int f3(float);
int f4(float);
int (*pf)(float);
```

则以下不合法的是:()


- **A** int (*p)(float)=&f1;
- **B** pf=&f4;
- **C** pf=&f2;
- **D** pf=f3;


答案：C


函数指针变量的声明方法为：

返回值类型 ( * 指针变量名) ([形参列表]);根据定义，

- int(*pf)(float);
- int (*p)(float)=&f1;

pf,p都是函数指针变量。

**函数地址**

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。函数地址的获取，可以是函数名，也可以在函数名前加取地址符&


---
假设寄存器为8位，用补码形式存储机器数，包括一位符号位，那么十进制数-25在寄存器表示为：

答案：E7H

求负数的反码，符号位不变，求补码时，符号位可变；


---
(多选)
在C++面向对象编程语言中，以下阐述不正确的是：

- **A** 接口中可以用虚方法
- **B** 一个类可以实现多个接口
- **C** 接口不能被实例化
- **D** 接口中可以包含已经实现的方法

答案：AD

这道题正确答案AD，首先所谓的接口是指只包含纯虚函数的抽象类，和普通的抽象类含不一样。所以A不对，必须是纯虚函数。然后B是正确的没有问题。然后是C，刚才说接口是特殊的抽象类，抽象类的唯一作用就是创建派生类，不能定义抽象类的对象，所以C是正确的。对于D，接口即只包含纯虚函数的抽象类，所以D是不对的。


---
(多选)
下面有关C++类说法正确的是()

- **A** 对基类成员的访问必须是无二义性的
- **B** 基类的公有成员在派生类中仍然是公有的
- **C** this指针保证基类保护成员在子类中可以被访问
- **D** 派生类一般都用公有派生

答案：AD

注：

- B:基类的公有成员在派生类中权限由派生规则决定
- C：this 代表本类


---

``` C++
char *p1;int64 *p2;
p1=(char *)0x800000;
p2=(int64 *)0x800000;
char *a=p1+2
int64_t *b=p2+2
```

那么a=  ,b= 


答案：0x800002,0x900010



---
在Windows 32位操作系统中，假设字节对齐为4，对于一个空的类A，sizeof(A)的值为（）？

答案：1

类的实例化是在内存中分配一块地址，每个实例在内存中都有独一无二的二地址。同样，空类也会实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化后就有独一无二的地址了。所以，空类的sizeof为1，而不是0. 多重继承的空类的大小也是1.


---

对于32位系统，定义 int **a[3][4], 则变量占有的内存空间为：_____

答案：48

---

写出程序的运行结果
``` C++
#include<iostream>
using namespace std;
 
class Base
{
    int x;
public:
    Base(int b): x(b) {}
    virtual void display()
    {
        cout << x;
    };
};
class Derived: public Base
{
    int y;
public:
    Derived(int d): Base(d), y(d) {} 
    void display()
    {
        cout << y;
    }
};
 
int main()
{
    Base b(1);
    Derived d(2);
    Base *p = & d;
    b.display();
    d.display();
    p->display();
    return 0;
 
}

```

答案：122

最后，d(2) Base *p = & d是把 派生类对象的地址&d赋值给指向基类对象的指针变量p。通过指向基类对象的指针，只能访问派生类中的基类成员，而不能访问派生类增加的成员。



---

以下代码打印的结果是（假设运行在 i386 系列计算机上）：
``` C++
struct st_t  
{
　　int status;
　　short *pdata;
　　char errstr[32];
};
 
st_t st[16];
char *p = (char *)( st[2].errstr + 32 );
printf( "%d", ( p - (char *)(st) ) );

```
答案：120



---
``` C++
char* s="AAA"; //1
printf("%s",s); //2
s[0]='B'; //3
printf("%s",s); //4

```
哪一句会出错？

答案：3

第3句错误，可以参考C专家编程p87，讲的很清楚，初始化指针时所创建的字符串常量被定义为只读。如果试图通过指针修改这个字符串的值，程序就会出现未定义的行为。S[0]只可读，不可写


---
关于函数的描述正确的是___。



- **A** 虚函数是一个static型的函数
- **B** 派生类的虚函数与基类的虚函数具有不同的参数个数和类型
- **C** 虚函数是一个非成员函数
- **D** 基类中说明了虚函数后，派生类中起对应的函数可以不必说明为虚函数​


答案：D


----

``` C++
void swap_int(int *a,int *b){
  *a=*a+*b;
  *b=*a-*b;
  *a=*a-*b;
}

```
以下说法正确的是

- **A** 结果不正确，因为会溢出，用位与的方式就没问题
- **B** 结果正确，即使会溢出
- **C** 结果正确，不会溢出
- **D** 其他选项都不对

答案：B

设整形变量*a、*b的位表示为
$$*a = n_{31}n_{30} ··· n_0$$
$$*b = m_{31}m_{30} ··· m_0$$
只有当$*a > 0 && *b > 0 $或 $*a < 0 && *b < 0$时才会发生溢出。

两者类似，只证明均大于0时的情况。必须扩展额外一位才能够容纳正确的结果，$|$ 左边为扩展位。
$$*a = 0|0 n_{30} ··· n_0 = n_{30}*2^{30} +  n_{29}*2^{29} + ··· + n_0*2^0 = N$$
$$*b = 0|0 m_{30} ··· m_0 = m_{30}*2^{30} +  m_{29}*2^{29} + ··· + m_0*2^0 = M$$
若和溢出，则33位表示必为
$$*a + *b = 0|1b_{30} ··· b_0 = -2^{31} + b_{30}*2^{30} +  b_{29}*2^{29} + ··· + b_0*2^0 =  2^{31}  + B \quad ①$$

计算机将得到的33位结果truncate回原来的32位，即丢弃第33位(0)变为：
$$*a + *b =    1b_{30} ··· b_0 = -2^{31} + b_{30}*2^{30} +  b_{29}*2^{29} + ··· + b_0*2^0 = -2^{31}   + B \quad ②$$

正确的真实值是①，溢出结果为②，可见: $\quad 溢出结果=真实值- 2^{32} $

则:
$$*b = *a - *b = ② - *b =  ① - 2^{32} - *b = *a + *b - 2^{32} - *b = -2^{32} + *a$$

最后一步，来看 $-2^{32} + *a  == *a $成立否？

$0 < *a < 2^{31}$, 则 $-2^{32} < -2^{32} + *a < -2^{31}$，和仍需要扩展1位方能表示：
$$*a    = 0|0n_{30} ··· n_0 = n_{30}*2^{30} +  n_{29}*2^{29} + ··· + n_0*2^0 = N$$
$$-2^{32} = 1|0000 ··· 00$$
和的位表示为
$$-2^{32} + *a = 1|0n_{30} ··· n_0 = n_{30}*2^{30} +  n_{29}*2^{29} + ··· + n_0*2^0$$
同样，计算机把33位结果truncate回32位（丢弃第33位）得到：
$$-2^{32} + *a =  0n_{30} ··· n_0 = n_{30}*2^{30} +  n_{29}*2^{29} + ··· + n_0*2^0 = *a$$
可见$-2^{32} + *a  == *a $是成立的。因此尽管溢出了，但仍能正确交换。


这道题首先得保证输入的两个参数不是指向同一个地址，否则，无论两个数如何，交换后的结果都将变为零，题目中没说明这一点。


---

下面代码的输出结果是()
``` C++
int main(){
   int pid;
   int num=1;
   pid=fork();
   if(pid>0){
   num++;
   printf("in parent:num:%d addr:%x\n",num,&num);
   }
   else if(pid==0){
   printf("in child:num:%d addr:%x\n",num,&num);
   }
}
```

- **A** 父子进程中输出的num相同,num地址不相同
- **B** 父子进程中输出的num不同,num地址相同
- **C** 父子进程中输出的num相同,num地址也相同
- **D** 父子进程中输出的num不同,num地址不相同

答案：B

虚拟地址空间。num地址的值相同，但是其真实的物理地址却不一样。linux下实现了一下，发现地址值真的一样。fork之后子进程复制了父进程的数据、堆栈。但是由于地址重定位器之类的魔法存在，所以，看似一样的地址空间（虚拟地址空间），其实却是不同的物理地址空间。同时可以验证c程序中输出的地址空间其实都是虚拟地址空间。


问题就出在地址想不相同，如果按照两个进程各处在独自的虚拟进程地址空间分析的话，这个题很容易会选择第四个答案，但是Linux中的资源分配都是虚拟机制，也就是说，他们还是会共用一个虚拟的地址，但是映射到物理内存就可能会不一样。


fork（）之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，但只有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因。 

勘误：子进程的pid是0，子进程的getpid()是它自己的进程号；父进程中的pid值为子进程进程号，只有父进程执行的getpid()才是他自己的进程号。






---
引用与指针有什么区别？

- **A** 指针是一个实体，而引用仅是个别名
- **B** 指针没有 const，引用有 const；
- **C** 引用不能为空，指针可以为空；
- **D** “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
- **E** 从内存分配上看：程序为引用变量分配内存区域，而指针不需要分配内存区域
- **F** 指针和引用的自增(++)运算，意义一样


答案：ACD


---

如下程序用于输出“Welcome to Huawei Test”,请指出其中的两处错误。
``` C++
char * GetWelcome(void){
    char * pcWelcome;
    char * pcNewWelcome;
    pcWelcome="Welcome to Huawei Test";
    pcNewWelcome=(char *)malloc(strlen(pcWelcome));    //1
    if(NULL==pcNewWelcome){
        return NULL;        //2
    }
    strcpy(pcNewWelcome, pcWelcome);    //3
    return pcNewWelcome;            //4
}

```

答案：1 3

第一处：malloc动态分配的内存是在堆上的，需要进行free()函数释放，这里假设是分配正确的，这样第四处就可以认为是正确的，因为它还没有释放。 

第二处：可以认为是在strcpy函数执行前的自检测，如果为NULL，由实现者决定其返回值，一般为NULL。 

第三处：strcpy函数的功能是把从src地址开始且含有'\0'结束符的字符串复制到以dest开始的地址空间。但是在第一处进行动态分配内存的时候使用的是strlen而不是sizeof，这样就少了'\0'结束符，不能正确进行复制操作。 因此，第一处和第三处是错误的。
